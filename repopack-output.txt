This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-17T14:23:47.066Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
README.md
requirements.txt
resources/names.json
resources/tracking.json
src/config/__init__.py
src/config/settings.py
src/core/__init__.py
src/core/utils.py
src/core/AutoVid.py
src/main.py
src/template/default.html
src/ui/__init__.py
src/ui/main_window.py

================================================================
Repository Files
================================================================

================
File: README.md
================
# Video Creator

This application automates the creation of videos by combining images and MP3 files, with optional custom metadata and HTML templating.

## Setup

1. Clone the repository:
git clone https://github.com/yourusername/video-creator.git
cd video-creator
Copy
2. Create a virtual environment and activate it:
python -m venv venv
source venv/bin/activate  # On Windows use venv\Scripts\activate
Copy
3. Install the required packages:
pip install -r requirements.txt
Copy
4. Ensure you have the `names.json` file in the `resources` directory.

## Usage

Run the application:
python src/main.py
Copy
Follow the on-screen instructions to select image and audio folders, choose a template, and create videos.

## Features

- Bulk video creation from folders of images and audio files
- Single video creation with manual file selection
- Custom HTML templating for video frames
- Random or custom metadata generation

## Project Structure

- `src/`: Source code
  - `main.py`: Entry point
  - `ui/`: User interface
  - `core/`: Core functionality
  - `config/`: Configuration and settings
  - `template/`: HTML templates
  - `output/`: Generated videos
- `resources/`: Resource files
- `requirements.txt`: Python dependencies
- `README.md`: This file

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License.

================
File: requirements.txt
================
# requirements.txt

PyQt6==6.4.0
moviepy==1.0.3
Jinja2==3.1.2
selenium==4.1.0
webdriver-manager==3.5.2
Pillow==9.3.0

================
File: resources/names.json
================
{
    "first_names": [
      "Aiko",
      "Aimi",
      "Airi",
      "Akari",
      "Amane",
      "Ayaka",
      "Ayane",
      "Chie",
      "Chiharu",
      "Chika",
      "Emi",
      "Emiko",
      "Erika",
      "Eri",
      "Fumiko",
      "Hana",
      "Hanako",
      "Haruka",
      "Hikari",
      "Hinata",
      "Hina",
      "Hitomi",
      "Honoka",
      "Hotaru",
      "Ikumi",
      "Itsuki",
      "Kaede",
      "Kana",
      "Kanako",
      "Kasumi",
      "Kaya",
      "Kazue",
      "Keiko",
      "Kiko",
      "Kira",
      "Kiyomi",
      "Koharu",
      "Kotone",
      "Kurumi",
      "Mai",
      "Maki",
      "Mana",
      "Manami",
      "Mao",
      "Mariko",
      "Marina",
      "Mayu",
      "Mayumi",
      "Megumi",
      "Mei",
      "Mika",
      "Miki",
      "Minami",
      "Mio",
      "Misa",
      "Misaki",
      "Mitsuki",
      "Mizuki",
      "Momoka",
      "Mutsuki",
      "Nagisa",
      "Nao",
      "Naoko",
      "Natsuki",
      "Natsumi",
      "Nene",
      "Noa",
      "Nodoka",
      "Noriko",
      "Reika",
      "Reina",
      "Ren",
      "Rika",
      "Riko",
      "Rina",
      "Rio",
      "Risa",
      "Risako",
      "Rui",
      "Saki",
      "Sakura",
      "Satomi",
      "Saya",
      "Sayaka",
      "Shiori",
      "Sora",
      "Sumire",
      "Suzuka",
      "Suzuki",
      "Takara",
      "Tomoka",
      "Tomomi",
      "Tsukiko",
      "Umeko",
      "Urara",
      "Yoko",
      "Yua",
      "Yui",
      "Yuka",
      "Yukari",
      "Yuki",
      "Yuko",
      "Yume",
      "Yumiko",
      "Yuna"
    ],
    "last_names": [
      "Abe",
      "Adachi",
      "Aoki",
      "Arakawa",
      "Chiba",
      "Doi",
      "Eguchi",
      "Endo",
      "Fujii",
      "Fujita",
      "Fukuda",
      "Goto",
      "Hamada",
      "Hasegawa",
      "Hayashi",
      "Hirano",
      "Hori",
      "Igarashi",
      "Ikeda",
      "Imai",
      "Inoue",
      "Ishibashi",
      "Ishida",
      "Ishikawa",
      "Ishimoto",
      "Ito",
      "Iwamoto",
      "Kamada",
      "Kaneko",
      "Kato",
      "Kawakami",
      "Kawasaki",
      "Kikuchi",
      "Kimura",
      "Kishimoto",
      "Kitagawa",
      "Kobayashi",
      "Kondo",
      "Kosaka",
      "Kubo",
      "Kudo",
      "Kumagai",
      "Kurihara",
      "Maeda",
      "Matsuda",
      "Matsui",
      "Matsumoto",
      "Matsuo",
      "Miyake",
      "Miyamoto",
      "Miyazaki",
      "Mizuno",
      "Morimoto",
      "Morioka",
      "Murakami",
      "Muto",
      "Nagano",
      "Nagai",
      "Nagata",
      "Nakagawa",
      "Nakamoto",
      "Nakamura",
      "Nakano",
      "Nakayama",
      "Nishi",
      "Nishida",
      "Nishimura",
      "Nomura",
      "Ogawa",
      "Ohashi",
      "Okada",
      "Okamoto",
      "Ono",
      "Onoda",
      "Ota",
      "Ozaki",
      "Saito",
      "Sakamoto",
      "Sakurai",
      "Sano",
      "Sasaki",
      "Shimizu",
      "Sugimoto",
      "Sugiyama",
      "Suzuki",
      "Takahashi",
      "Takaki",
      "Takeda",
      "Takeuchi",
      "Tanaka",
      "Tani",
      "Tanikawa",
      "Tashiro",
      "Tokuda",
      "Tomita",
      "Toyoda",
      "Tsuda",
      "Ueda",
      "Ueno",
      "Wada",
      "Watanabe",
      "Yamada",
      "Yamaguchi",
      "Yamamoto",
      "Yamashita",
      "Yoshida"
    ]
  }

================
File: resources/tracking.json
================
{
    "songs": [
        "neon city",
        "neon city",
        "Neon City",
        "Urban Illusion"
    ],
    "combinations": [
        "Urara Miyake_neon city_1984",
        "Megumi Matsumoto_neon city_1981",
        "Momoka Ishibashi_Neon City_1981",
        "Kira Sakurai_Urban Illusion_1986"
    ],
    "images": [
        {
            "song": "neon city",
            "artist": "Urara Miyake",
            "year": "1984",
            "image": "FbdGkI8kSk2n4uhazi1-uA.png"
        },
        {
            "song": "neon city",
            "artist": "Megumi Matsumoto",
            "year": "1981",
            "image": "FbdGkI8kSk2n4uhazi1-uA.png"
        },
        {
            "song": "Neon City",
            "artist": "Momoka Ishibashi",
            "year": "1981",
            "image": "woman (6).jpeg"
        },
        {
            "song": "Urban Illusion",
            "artist": "Kira Sakurai",
            "year": "1986",
            "image": "woman (8).jpeg"
        }
    ]
}

================
File: src/config/__init__.py
================
# src/config/__init__.py

# This file can be left empty. It's used to mark the directory as a Python package.

================
File: src/config/settings.py
================
# src/config/settings.py

import os

# Base directories
BASE_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
SRC_DIR = os.path.join(BASE_DIR, 'src')
RESOURCES_DIR = os.path.join(BASE_DIR, 'resources')

# Output and working directories
OUTPUT_DIR = os.path.join(SRC_DIR, 'output')
SCREENSHOTS_DIR = os.path.join(OUTPUT_DIR, 'screenshots')
TEMPLATE_DIR = os.path.join(SRC_DIR, 'template')

# File paths
CONFIG_FILE = os.path.join(RESOURCES_DIR, 'config.json')
NAMES_FILE = os.path.join(RESOURCES_DIR, 'names.json')
TRACKING_FILE = os.path.join(RESOURCES_DIR, 'tracking.json')

# Ensure necessary directories exist
os.makedirs(OUTPUT_DIR, exist_ok=True)
os.makedirs(SCREENSHOTS_DIR, exist_ok=True)
os.makedirs(TEMPLATE_DIR, exist_ok=True)

# Application settings
APP_NAME = "Video Creator"
APP_VERSION = "1.0.0"

# Video settings
DEFAULT_FPS = 24
MIN_YEAR = 1978
MAX_YEAR = 1986

# You can add more settings as needed

================
File: src/core/__init__.py
================
# src/core/__init__.py

# This file can be left empty or you can use it to import and expose certain modules if needed
# For now, let's leave it empty

================
File: src/core/utils.py
================
# src/core/utils.py

import json
import re
from config.settings import NAMES_FILE, TRACKING_FILE

def sanitize_filename(name):
    """Sanitize the filename by removing unsafe characters and replacing spaces"""
    return re.sub(r'[\/:*?"<>|]', '', name).replace(' ', '_')

def parse_filename(filename):
    """Parse filename to extract song name, artist, and year"""
    pattern = r"(.+)_(.+)_(\d{4})\.mp3"
    match = re.match(pattern, filename)
    return match.groups() if match else (None, None, None)

def load_names(names_file=NAMES_FILE):
    """Load names from the names.json file"""
    try:
        with open(names_file, 'r') as f:
            names_data = json.load(f)
        return names_data['first_names'], names_data['last_names']
    except FileNotFoundError:
        print(f"Names file '{names_file}' not found.")
        return [], []

def load_tracking(tracking_file=TRACKING_FILE):
    """Load the tracking data from file"""
    try:
        with open(tracking_file, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def save_tracking(tracking_data, tracking_file=TRACKING_FILE):
    """Save the tracking data to file"""
    with open(tracking_file, 'w', encoding='utf-8') as f:
        json.dump(tracking_data, f, ensure_ascii=False, indent=4)

================
File: src/core/video_creator.py
================
# src/core/video_creator.py

import os
import random
import traceback
import tempfile
import shutil
import base64
from io import BytesIO
import time
from PIL import Image
from PyQt6.QtCore import QThread, pyqtSignal
from moviepy.editor import ImageClip, AudioFileClip, concatenate_videoclips
from jinja2 import Template
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from webdriver_manager.chrome import ChromeDriverManager
from config.settings import OUTPUT_DIR, SCREENSHOTS_DIR, NAMES_FILE, TEMPLATE_DIR
from core.utils import load_names, load_tracking, save_tracking, sanitize_filename, parse_filename

class VideoCreatorThread(QThread):
    progress_signal = pyqtSignal(str)
    finished_signal = pyqtSignal(bool, str)

    def __init__(self, image_folder, audio_folder, html_template, single_image=None, single_audio=None, custom_artist=None, custom_year=None):
        super().__init__()
        self.image_folder = os.path.abspath(image_folder)
        self.audio_folder = os.path.abspath(audio_folder)
        self.html_template = html_template
        self.single_image = single_image
        self.single_audio = single_audio
        self.custom_artist = custom_artist
        self.custom_year = custom_year
        self.temp_dir = tempfile.mkdtemp()
        self.screenshots_dir = os.path.join(OUTPUT_DIR, 'screenshots')
        os.makedirs(self.screenshots_dir, exist_ok=True)

    def run(self):
        try:
            # Load names and tracking data
            first_names, last_names = load_names(NAMES_FILE)
            tracking_data = load_tracking()

            # Setup Selenium WebDriver
            driver_path = ChromeDriverManager().install()
            service = Service(driver_path)
            options = webdriver.ChromeOptions()
            options.add_argument("--headless")
            driver = webdriver.Chrome(service=service, options=options)

            # Get list of images and audio files
            if self.single_image and self.single_audio:
                image_files = [self.single_image]
                audio_files = [self.single_audio]
            else:
                # image_files = [f for f in os.listdir(self.image_folder) if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                image_files = [os.path.join(self.image_folder, f) for f in os.listdir(self.image_folder) if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
                audio_files = [os.path.join(self.audio_folder, f) for f in os.listdir(self.audio_folder) if f.lower().endswith('.mp3')]

            if not image_files or not audio_files:
                self.finished_signal.emit(False, "No image or audio files found.")
                return

            # Load HTML template if provided
            use_template = bool(self.html_template)
            template = None
            if use_template:
                with open(self.html_template, 'r') as file:
                    template = Template(file.read())

            # Create output and screenshots directories
            os.makedirs(OUTPUT_DIR, exist_ok=True)
            os.makedirs(SCREENSHOTS_DIR, exist_ok=True)

            # Process each audio file
            for audio in audio_files:
                self.progress_signal.emit(f"Processing {os.path.basename(audio)}")
                print(f"Debug - Processing audio: {audio}")  # Debug print

                # Generate or use provided metadata
                song_name, artist_name, year = self.generate_metadata(audio, first_names, last_names, tracking_data)

                # Select image and create video
                selected_image = self.select_image(image_files)
                print(f"Debug - Selected image: {selected_image}")  # Debug print
                self.create_video(driver, template, selected_image, audio, song_name, artist_name, year, use_template)

                # Update tracking data
                self.update_tracking(tracking_data, song_name, artist_name, year, selected_image)

            driver.quit()
            save_tracking(tracking_data)

            # Clean up
            shutil.rmtree(self.temp_dir)

            self.finished_signal.emit(True, f"Videos created successfully in: {OUTPUT_DIR}")
        except Exception as e:
            error_message = f"Error creating video: {str(e)}\n{traceback.format_exc()}"
            print(error_message)  # Print to console
            self.finished_signal.emit(False, error_message)

    def generate_metadata(self, audio, first_names, last_names, tracking_data):
        """Generate or retrieve metadata for the audio file"""
        song_name, _, _ = parse_filename(os.path.basename(audio))
        if not song_name:
            song_name = os.path.splitext(os.path.basename(audio))[0]

        if self.custom_artist:
            artist_name = self.custom_artist
        else:
            artist_name = f"{random.choice(first_names)} {random.choice(last_names)}"

        if self.custom_year:
            year = self.custom_year
        else:
            year = str(random.randint(1978, 1986))

        return song_name, artist_name, year

    def select_image(self, image_files):
        if self.single_image:
            return os.path.join(self.image_folder, self.single_image)
        return random.choice(image_files)  # image_files should already contain full paths

    def create_video(self, driver, template, image_path, audio_path, song_name, artist_name, year, use_template):
        print(f"Debug - Image path: {image_path}")  # Debug print
        if not os.path.exists(image_path):
            raise FileNotFoundError(f"Image file not found: {image_path}")
        
        # If using a template, ensure screenshot_path is correctly set
        if use_template and template is not None:
            screenshot_path = self.create_screenshot(driver, template, image_path, song_name, artist_name, year)
        else:
            screenshot_path = image_path
        
        print(f"Debug - Screenshot path: {screenshot_path}")  # Debug print
        """Create a video from the given image and audio"""
        if use_template and template is not None:
            screenshot_path = self.create_screenshot(driver, template, image_path, song_name, artist_name, year)
        else:
            screenshot_path = image_path

        audio_clip = AudioFileClip(audio_path)  # Make sure audio_path is the full path
        img_clip = ImageClip(screenshot_path).set_duration(audio_clip.duration)
        video_clip = img_clip.set_audio(audio_clip)

        output_video_name = f"{sanitize_filename(artist_name)}_{sanitize_filename(song_name)}_{year}.mp4"
        output_path = os.path.join(OUTPUT_DIR, output_video_name)

        video_clip.write_videofile(output_path, fps=24)

    def create_screenshot(self, driver, template, image_path, song_name, artist_name, year):
        """Create a screenshot using the HTML template"""

        # Dictionary to store base64-encoded images
        image_data = {}

        # Base64 encode template images (e.g., container_background, photo_background, logo)
        for img_name in ['container_background', 'photo_background', 'logo']:
            for ext in ['.png', '.jpg', '.jpeg']:
                img_path = os.path.join(TEMPLATE_DIR, f"{img_name}{ext}")
                if os.path.exists(img_path):
                    with open(img_path, "rb") as image_file:
                        image_data[img_name] = base64.b64encode(image_file.read()).decode()
                    break  # Stop after finding the first valid image

        # Base64 encode the selected image passed to the function
        with open(image_path, "rb") as image_file:
            main_image_data = base64.b64encode(image_file.read()).decode()

        # Render the HTML template with all the image data
        html_content = template.render(
            container_background=image_data.get('container_background', ''),
            photo_background=image_data.get('photo_background', ''),
            logo=image_data.get('logo', ''),
            image_base64=main_image_data,
            song_name=song_name,
            song_artist=artist_name,
            song_year=year
        )

        # Save the rendered HTML to a temporary file
        temp_html = os.path.join(self.temp_dir, 'temp.html')
        with open(temp_html, 'w', encoding='utf-8') as f:
            f.write(html_content)

        # Load the HTML in the browser via Selenium
        driver.get(f"file://{os.path.abspath(temp_html)}")

        # Wait for the page to finish rendering
        driver.implicitly_wait(2)

        # Get the full size of the page content
        width = driver.execute_script("return Math.max(document.body.scrollWidth, document.body.offsetWidth, document.documentElement.clientWidth, document.documentElement.scrollWidth, document.documentElement.offsetWidth);")
        height = driver.execute_script("return Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);")

        # Set the browser window size
        driver.set_window_size(width, height)

        # Wait for the resize to take effect
        time.sleep(1)

        # Take the screenshot
        screenshot = driver.get_screenshot_as_png()
        image = Image.open(BytesIO(screenshot))

        # Save the screenshot
        screenshot_path = os.path.join(self.screenshots_dir, f"{song_name}_{artist_name}_{year}.png")
        image.save(screenshot_path)

        # Clean up the temporary HTML file
        os.remove(temp_html)
        screenshot_path = os.path.join(self.screenshots_dir, f"{song_name}_{artist_name}_{year}.png")
        print(f"Debug - Saving screenshot to: {screenshot_path}")  # Debug print
        image.save(screenshot_path)
        
        return screenshot_path

    def update_tracking(self, tracking_data, song_name, artist_name, year, image):
        """Update the tracking data"""
        if not self.single_audio:
            if 'songs' not in tracking_data:
                tracking_data['songs'] = []
            if 'combinations' not in tracking_data:
                tracking_data['combinations'] = []
            if 'images' not in tracking_data:
                tracking_data['images'] = []

            tracking_data['songs'].append(song_name)
            tracking_data['combinations'].append(f"{artist_name}_{song_name}_{year}")
            tracking_data['images'].append({
                'song': song_name,
                'artist': artist_name,
                'year': year,
                'image': os.path.basename(image)
            })

================
File: src/main.py
================
# src/main.py

import sys
from PyQt6.QtWidgets import QApplication
from ui.main_window import VideoCreatorApp

def main():
    """
    Main entry point of the application.
    Initializes and runs the main window.
    """
    app = QApplication(sys.argv)
    window = VideoCreatorApp()
    window.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()

================
File: src/template/default.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Music Information Card</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;700&display=swap");

      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
      }

      body {
        overflow: hidden;
        font-family: "Noto Sans", sans-serif;
        background-color: #f5f5f5;
        background-image: url(data:image/png;base64,{{ photo_background }});
        background-size: 120%;
        background-position: center;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 1920px;
        height: 1080px;
      }

      .container {
        margin-top: -150px;
        width: 500px;
        background-image: url(data:image/png;base64,{{ photo_background }});
        background-size: cover;
        background-position: center;
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0px 6px 12px rgba(0, 0, 0, 0.2);
      }

      .image-container {
        position: relative;
        width: 100%;
        height: 500px;
        /* background-image: url(data:image/png;base64,{{ image_base64 }}); */
        background-size: cover;
        background-position: center;
        border-radius: 12px;
        margin-bottom: 20px;
      }

      .bottom-content {
        display: flex;
        justify-content: space-between;
      }

      .logo {
        position: relative;
        background-image: url(data:image/png;base64,{{ logo }});
        background-size: cover;
        background-position: center;
        border-radius: 100%;
        width: 150px;
        height: 150px;
        background-size: 160%;
      }

      .music-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 20px;
      }

      .music-info h1 {
        font-size: 32px;
        margin: 0;
        font-weight: 700;
        color: #333;
      }

      .music-info p {
        font-size: 18px;
        margin: 5px 0;
        font-weight: 400;
        color: #777;
      }

      .music-info .details {
        display: flex;
        flex-direction: column;
      }

      .choice {
        display: flex;
        justify-content: space-between;
        margin-top: 30px;
      }

      .choice p {
        font-size: 24px;
        font-weight: bold;
        margin: 0;
      }

      .choice .option {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .description {
        text-align: center;
        margin-top: 10px;
        font-size: 16px;
        color: #666;
      }
    </style>
  </head>
  <body>
    <div class="container">
    <img  class="image-container" src="data:image/jpeg;base64,{{ image_base64 }}" alt="{{ song_name }}">
      <!-- <div class="image-container"> -->
        <!-- Embedded image as background -->
      <!-- </div> -->
      <div class="bottom-content">
        <div class="music-info">
          <div class="details">
            <h1>{{ song_name }}</h1>
            <p>Artist: {{ song_artist }}</p>
            <p>Year: {{ song_year }}</p>
          </div>
        </div>
        <div>
          <div class="logo"></div>
        </div>
      </div>
    </div>
  </body>
</html>

================
File: src/ui/__init__.py
================
# src/ui/__init__.py

# This file can be left empty. It's used to mark the directory as a Python package.

================
File: src/ui/main_window.py
================
# src/ui/main_window.py

from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QPushButton, 
    QFileDialog, QLabel, QMessageBox, QLineEdit, QComboBox
)
from PyQt6.QtCore import Qt
from core.video_creator import VideoCreatorThread
from config.settings import OUTPUT_DIR, TEMPLATE_DIR
import os

class VideoCreatorApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Video Creator")
        self.setGeometry(100, 100, 500, 450)
        self.init_ui()

    def init_ui(self):
        """Initialize the user interface"""
        
        layout = QVBoxLayout()
        # Template selection
        self.template_label = QLabel("Select Template:")
        layout.addWidget(self.template_label)
        self.template_dropdown = QComboBox()
        self.populate_template_dropdown()
        layout.addWidget(self.template_dropdown)

        # Image folder selection
        self.image_folder_label = QLabel("Image Folder: Not selected")
        layout.addWidget(self.image_folder_label)
        self.select_image_folder_button = QPushButton("Select Image Folder")
        self.select_image_folder_button.clicked.connect(self.select_image_folder)
        layout.addWidget(self.select_image_folder_button)

        # Audio folder selection
        self.audio_folder_label = QLabel("Audio Folder: Not selected")
        layout.addWidget(self.audio_folder_label)
        self.select_audio_folder_button = QPushButton("Select Audio Folder")
        self.select_audio_folder_button.clicked.connect(self.select_audio_folder)
        layout.addWidget(self.select_audio_folder_button)



        # Bulk video creation
        self.create_video_button = QPushButton("Create Videos")
        self.create_video_button.clicked.connect(self.create_videos)
        layout.addWidget(self.create_video_button)

        # Single video creation
        self.manual_selection_label = QLabel("Manual Selection:")
        layout.addWidget(self.manual_selection_label)
        self.select_single_image_button = QPushButton("Select Single Image")
        self.select_single_image_button.clicked.connect(self.select_single_image)
        layout.addWidget(self.select_single_image_button)
        self.select_single_audio_button = QPushButton("Select Single Audio")
        self.select_single_audio_button.clicked.connect(self.select_single_audio)
        layout.addWidget(self.select_single_audio_button)
        self.artist_name_input = QLineEdit()
        self.artist_name_input.setPlaceholderText("Artist Name (optional)")
        layout.addWidget(self.artist_name_input)
        self.year_input = QLineEdit()
        self.year_input.setPlaceholderText("Year (optional)")
        layout.addWidget(self.year_input)
        self.create_single_video_button = QPushButton("Create Single Video")
        self.create_single_video_button.clicked.connect(self.create_single_video)
        layout.addWidget(self.create_single_video_button)

        # Status display
        self.status_label = QLabel("")
        layout.addWidget(self.status_label)

        # Set central widget
        container = QWidget()
        container.setLayout(layout)
        self.setCentralWidget(container)

        # Initialize variables
        self.image_folder = ""
        self.audio_folder = ""
        self.single_image = ""
        self.single_audio = ""

    def populate_template_dropdown(self):
        """Populate the template dropdown with available templates"""
        self.template_dropdown.addItem("No Template", "")
        for file in os.listdir(TEMPLATE_DIR):
            if file.endswith('.html'):
                self.template_dropdown.addItem(file, os.path.join(TEMPLATE_DIR, file))

    def select_image_folder(self):
        """Open a dialog to select the image folder"""
        folder = QFileDialog.getExistingDirectory(self, "Select Image Folder")
        if folder:
            self.image_folder = folder
            self.image_folder_label.setText(f"Image Folder: {folder}")

    def select_audio_folder(self):
        """Open a dialog to select the audio folder"""
        folder = QFileDialog.getExistingDirectory(self, "Select Audio Folder")
        if folder:
            self.audio_folder = folder
            self.audio_folder_label.setText(f"Audio Folder: {folder}")

    def select_single_image(self):
        """Open a dialog to select a single image file"""
        file, _ = QFileDialog.getOpenFileName(self, "Select Single Image", "", "Image Files (*.png *.jpg *.jpeg)")
        if file:
            self.single_image = file
            self.select_single_image_button.setText(f"Image: {os.path.basename(file)}")

    def select_single_audio(self):
        """Open a dialog to select a single audio file"""
        file, _ = QFileDialog.getOpenFileName(self, "Select Single Audio", "", "Audio Files (*.mp3)")
        if file:
            self.single_audio = file
            self.select_single_audio_button.setText(f"Audio: {os.path.basename(file)}")

    def create_videos(self):
        """Start the process of creating multiple videos"""
        if not self.image_folder or not self.audio_folder:
            QMessageBox.warning(self, "Error", "Please select image folder and audio folder.")
            return

        self.status_label.setText("Creating videos...")
        self.create_video_button.setEnabled(False)

        selected_template = self.template_dropdown.currentData()
        self.thread = VideoCreatorThread(self.image_folder, self.audio_folder, selected_template)
        self.thread.progress_signal.connect(self.update_progress)
        self.thread.finished_signal.connect(self.video_creation_finished)
        self.thread.start()

    def create_single_video(self):
        """Start the process of creating a single video"""
        if not self.single_image or not self.single_audio:
            QMessageBox.warning(self, "Error", "Please select an image and audio file.")
            return

        artist_name = self.artist_name_input.text()
        year = self.year_input.text()

        self.status_label.setText("Creating single video...")
        self.create_single_video_button.setEnabled(False)

        selected_template = self.template_dropdown.currentData()
        self.thread = VideoCreatorThread(self.image_folder, self.audio_folder, selected_template,
                                         single_image=self.single_image, single_audio=self.single_audio,
                                         custom_artist=artist_name, custom_year=year)
        self.thread.progress_signal.connect(self.update_progress)
        self.thread.finished_signal.connect(self.video_creation_finished)
        self.thread.start()

    def update_progress(self, message):
        """Update the status label with progress messages"""
        self.status_label.setText(message)

    def video_creation_finished(self, success, message):
        """Handle the completion of video creation"""
        self.create_video_button.setEnabled(True)
        self.create_single_video_button.setEnabled(True)
        if success:
            QMessageBox.information(self, "Success", f"Videos created successfully in:\n{OUTPUT_DIR}")
        else:
            QMessageBox.warning(self, "Error", message)
        self.status_label.setText("")
